#+title: Leuven shell configuration files

#+PROPERTY:  header-args :tangle bin/rc-bash-specific-settings-shell-leuven-new

#+begin_src shell
#!/usr/bin/env bash
#+end_src

* 1. Environment variables

These are variables that are accessible to all parts of the shell
environment.

#+begin_src shell
if [ -r ~/.dircolors ]; then
    eval "$(dircolors ~/.dircolors)"
fi
#+end_src

This command sets the ~LS_COLORS~ environment variable by evaluating the output of
the ~dircolors~ command.

* 2. Paths

These are specific paths to files and directories.

For example, the ~PATH~ environment variable tells the shell where to look for
executable files.

#+begin_src shell
# Add ~/bin to PATH if not already present.
if [[ ":$PATH:" != *":$HOME/bin:"* ]]; then
    export PATH="$HOME/bin:$PATH";
fi

# Add ~/winbin to PATH if not already present.
if [[ ":$PATH:" != *":$HOME/winbin:"* ]]; then
    export PATH="$HOME/winbin:$PATH";
fi
#+end_src

* 3. Aliases

These are shortened names for commands.

For example, you might set an alias for the ~ls~ command to ~ll~.

#+begin_src shell
alias ll='ls -l'
#+end_src

#+begin_src shell :tangle bin/rc-common-settings-shell-leuven-new
#!/usr/bin/env bash

# Alias 'hgrep' to search command history with case-insensitive grep.
alias hgrep='history | grep -i'

# Check if 'rg' command is available.
if command -v rg > /dev/null 2>&1; then
    # Alias 'rgno' to 'rg -l' to list filenames with matches.
    alias rgno='rg -l'

    # Alias 'rgext' to perform a case-insensitive search within files matching
    # a specific pattern.
    alias rgext='function _rgext() { rg --glob "*.$1" -i -C 1 "$2"; }; _rgext'
fi
#+end_src

#+begin_src shell
alias lsd='ls -d */'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

alias -- -='cd -'

alias d='dirs -v'
alias 1='cd -1'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
alias 6='cd -6'
alias 7='cd -7'
alias 8='cd -8'
alias 9='cd -9'
#+end_src

* 4. Functions

These are blocks of code that can be executed by name. For example, you might
create a function to format your prompt.

function my_function
    echo "Hello, Fish!"
end

* 5. Key bindings

These are mappings of keys to commands. For example, you might bind the Ctrl+A
key to move the cursor to the beginning of the line.

bind \ct command_name

* 6. Prompt configuration

This is the configuration of the terminal prompt. This includes things like the
colors, the text that is displayed, and the layout of the prompt.

#+begin_src shell
# Customize PS1 prompt.

# Define a custom function to display the exit code in red if it's non-zero.
show_exit_code() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        printf "\033[01;31m%s\033[00m\n" "$exit_code"
    else
        printf "%s" ""
    fi
}

# Set the PROMPT_COMMAND to call the custom function.
PROMPT_COMMAND='show_exit_code'



PS1='\n\
\[\e]0;\u@\h: \w\a\]\
${debian_chroot:+($debian_chroot)}\
\[\033[01;32m\]\u@\h\[\033[00m\]\
\[\033[01;30m\]:\[\033[00m\]\
\[\033[01;34m\]\w\[\033[00m\] \
\[\033[01;33m\]($(git branch 2>/dev/null | grep '^*' | colrm 1 2))\
\[\033[0m\]\n\$ '

PS1='\n\
\[\e]0;\u@\h: \w\a\]\
${debian_chroot:+($debian_chroot)}\
\[\033[01;32m\]\u@\h\[\033[00m\]\
\[\033[01;30m\]:\[\033[00m\]\
\[\033[01;34m\]\w\[\033[00m\]\
\[\033[01;33m\]$(__git_ps1)\
\[\033[0m\]\n\$ '

__git_ps1() {
    local git_info
    git_info="$(git rev-parse --is-inside-work-tree 2>/dev/null)"

    if [[ -z "$git_info" ]]; then
        return $?
    fi

    local branch
    if branch="$(git symbolic-ref --short -q HEAD 2>/dev/null)"; then
        : # We are on a branch, nothing to do here.
    else
        branch="$(git rev-parse --short HEAD 2>/dev/null)"
    fi

    local dirty=""                      # should be in red
    local staged=""                     # should be in magenta
    local stash=""                      # should be in blue
    local untracked=""                  # should be in green
    local outgoing=""                   # should be in yellow
    local incoming=""                   # should be in cyan

    if [[ -n "$(git diff --no-ext-diff --quiet || echo '*')" ]]; then
        dirty=" *dirty"
    fi

    if [[ -n "$(git diff --no-ext-diff --cached --quiet || echo '+')" ]]; then
        staged=" +staged"
    fi

    if git rev-parse --verify --quiet refs/stash >/dev/null; then
        stash=" \$stash"
    fi

    if git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null; then
        untracked=" ?untracked"
    fi

    local count_outgoing=0
    local count_incoming=0
    local upstream_branch

    if upstream_branch="$(git rev-parse --abbrev-ref @{u} 2>/dev/null)"; then
        count_outgoing=$(git rev-list --count --left-right @{u}...HEAD 2>/dev/null | awk '{print $2}')
        count_incoming=$(git rev-list --count --left-right @{u}...HEAD 2>/dev/null | awk '{print $1}')
    fi

    if (( count_outgoing > 0 )); then
        outgoing=" ↑$count_outgoing"
    fi

    if (( count_incoming > 0 )); then
        incoming=" ↓$count_incoming"
    fi

    local status_info="$dirty$staged$stash$untracked$outgoing$incoming"

    branch="${branch##refs/heads/}"
    printf -- " (%s)" "$branch$(tput setaf 6)${status_info:+$status_info}$(tput setaf 3)"
}

# XXX Make use of color_prompt variable?
#+end_src

* 7. Autosuggestions

These are suggestions for commands that are based on the current input. For
example, if you type ls, the shell might show you suggestions for other commands
that start with ls.

fish_add_path_to_function_path /path/to/function

* 8. Completions

These are completions for commands and file paths. For example, if you type cd,
the shell might show you a list of directories that you can change to.

complete -c command_name -f -n '__fish_use_subcommand'

* 9. Universal variables

These are variables that are shared by all shells. For example, the USER
variable tells the shell your username.

set -Ux UNIVERSAL_VARIABLE value

* 10. Abbreviations

These are shortened names for words or phrases. For example, you might set an
abbreviation for the word Linux to lx.

abbr --add git "git_command"

* 11. Event handling

This is the configuration of how the shell responds to events, such as key
presses and file system changes.

function fish_title
    echo "Terminal Title"
end

* 12. Miscellaneous settings

This is a catch-all category for settings that don't fit into any of the other
categories.

set -g fish_color_autosuggestion brblack
set -g fish_color_match yellow

* Additional custom configurations or settings

** Bash-specific settings

** Zsh-specific settings

** Common settings

#+begin_src shell
# Check if history search bindings are already set.
if ! bind -q history-search-backward &>/dev/null; then
    # If not set, configure Up and Down arrow keys for history search.
    bind '"\e[A": history-search-backward'
                                        # Up arrow: Search backward in command
                                        # history.
    bind '"\e[B": history-search-forward'
                                        # Down arrow: Search forward in command
                                        # history.
fi

# Configure HISTCONTROL to ignore both leading space and consecutive duplicates.
export HISTCONTROL=ignoreboth
# === default in Ubuntu



# Enable case-insensitive directory completion.
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"




# Set the number of commands to remember in the in-memory history.
export HISTSIZE=10000

# Set the history timestamp format to ISO8601 (yyyy-mm-dd hh:mm).
export HISTTIMEFORMAT="%Y-%m-%d %H:%M  "

# Exclude common navigation and administrative commands from history.
export HISTIGNORE="ls:cd:pwd:clear:history:exit:top:df"

# Detect the current shell.
case "$SHELL" in
    */bash)
        # Set a common history file.
        HISTFILE=$HOME/.bash_history

        # Set the number of history entries to save to the (on-disk history)
        # file.
        export HISTFILESIZE=20000

        # Append to the history file instead of overwriting it.
        shopt -s histappend

        # Add history management to the existing PROMPT_COMMAND: after each
        # command, append to the history file and reload it.
        if [ -n "$PROMPT_COMMAND" ]; then
            PROMPT_COMMAND="$PROMPT_COMMAND; history -a; history -n"
        else
            PROMPT_COMMAND="history -a; history -n"
        fi
        ;;
    */zsh)
        # Set a common history file.
        HISTFILE=$HOME/.zsh_history

        # Set the number of history entries to save to the (on-disk history)
        # file.
        SAVEHIST=20000

        # Share history between all running sessions.
        setopt SHARE_HISTORY

        # Append commands to the history file incrementally, instead of
        # overwriting the history file when the shell exits.
        setopt INC_APPEND_HISTORY

        # Append to the history file instead of overwriting it.
        setopt APPEND_HISTORY

        setopt HIST_IGNORE_SPACE
        setopt HIST_SAVE_NO_DUPS
        setopt HIST_EXPIRE_DUPS_FIRST

        # Show full command history without line numbers.
        alias history="history 0"
        ;;
esac
#+end_src



#+begin_src shell
# autopushd() {
#     if [[ -n "$BASH_VERSION" ]]; then
#         # For Bash.
#         old_dir="$(pwd)"
#         builtin cd "$@"
#         if [[ ":$DIRSTACK:" != *":$old_dir:"* ]]; then
#             echo "Bash - Pushing $old_dir onto the stack:"
#             pushd "$old_dir"
#         else
#             echo "Bash - Directory already in stack, not pushing."
#         fi
#     elif [[ -n "$ZSH_VERSION" ]]; then
#         # For Zsh.
#         old_dir="$(pwd)"
#         cd "$@"
#         if [[ ! -v dirstack || ":$DIRSTACK:" != *":$old_dir:"* ]]; then
#             echo "Zsh - Pushing $old_dir onto the stack:"
#             pushd "$old_dir"
#         else
#             echo "Zsh - Directory already in stack, not pushing."
#         fi
#     fi
# }
#
# alias cd='autopushd'
#+end_src

#+begin_src shell
export GREP_COLORS='ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32'
#+end_src

* Adding custom configuration to .bashrc or .zshrc

To automatically source custom settings files every time you start a new
terminal session, you can add the following code snippet to your =.bashrc= or
=.zshrc= file. This script will look for files matching specific patterns in your
=~/bin/= directory and source them if they exist.

** For Bash users

#+begin_src shell :tangle no
# Source custom settings files (beginning with 'rc-bash' or 'rc-common') from
# ~/bin.
for file in ~/bin/rc-bash-specific-settings-* ~/bin/rc-common-settings-*; do
    if [[ -f "$file" ]]; then
        printf "Sourcing %s...\n" "$file"
        source "$file"
    fi
done
#+end_src

** For Zsh users

#+begin_src shell :tangle no
# Source custom settings files (beginning with 'rc-zsh' or 'rc-common') from
# ~/bin.
for file in ~/bin/rc-zsh-specific-settings-* ~/bin/rc-common-settings-*; do
    if [[ -f "$file" ]]; then
        printf "Sourcing %s...\n" "$file"
        source "$file"
    fi
done
#+end_src
