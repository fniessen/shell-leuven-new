#!/usr/bin/env bash

# Customize PS1 prompt.

# Define a custom function to display the exit code in red if it's non-zero.
show_exit_code() {
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        printf "\033[01;31m%s\033[00m\n" "$exit_code"
    else
        printf "%s" ""
    fi
}

# Set the PROMPT_COMMAND to call the custom function.
PROMPT_COMMAND='show_exit_code'



PS1='\n\
\[\e]0;\u@\h: \w\a\]\
${debian_chroot:+($debian_chroot)}\
\[\033[01;32m\]\u@\h\[\033[00m\]\
\[\033[01;30m\]:\[\033[00m\]\
\[\033[01;34m\]\w\[\033[00m\] \
\[\033[01;33m\]($(git branch 2>/dev/null | grep '^*' | colrm 1 2))\
\[\033[0m\]\n\$ '

PS1='\n\
\[\e]0;\u@\h: \w\a\]\
${debian_chroot:+($debian_chroot)}\
\[\033[01;32m\]\u@\h\[\033[00m\]\
\[\033[01;30m\]:\[\033[00m\]\
\[\033[01;34m\]\w\[\033[00m\]\
\[\033[01;33m\]$(__git_ps1)\
\[\033[0m\]\n\$ '




# XXX Make use of color_prompt variable?

# Check if history search bindings are already set.
if ! bind -q history-search-backward &>/dev/null; then
    # If not set, configure Up and Down arrow keys for history search.
    bind '"\e[A": history-search-backward'   # Up arrow: Search backward in command history.
    bind '"\e[B": history-search-forward'    # Down arrow: Search forward in command history.
fi

# Configure HISTCONTROL to ignore both leading space and consecutive duplicates.
export HISTCONTROL=ignoreboth
# === default in Ubuntu



# Enable case-insensitive directory completion.
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"



PATH="$HOME/winbin:$HOME/bin:$PATH"

alias g=git
alias hgrep='history | grep -i'


# Source all files beginning with 'rc-bash' or 'rc-common' in the ~/bin directory.
for file in ~/bin/rc-bash* ~/bin/rc-common*; do
    if [ -f "$file" ]; then
        printf "Sourcing %s...\n" "$file"
        . "$file"
    fi
done

__git_ps1() {
    local git_info
    git_info="$(git rev-parse --is-inside-work-tree --short HEAD 2>/dev/null)"

    if [ -z "$git_info" ]; then
        return $?
    fi

    local branch
    if [ -h "$(git rev-parse --git-path HEAD 2>/dev/null)" ]; then
        branch="$(git symbolic-ref HEAD 2>/dev/null)"
    else
        local head_ref
        if ! __git_eread "$(git rev-parse --git-path HEAD)" head_ref; then
            return $?
        fi
        branch="${head_ref#ref: }"
    fi

    local dirty=""
    local staged=""
    local stash=""
    local untracked=""

    if [ -n "$(git diff --no-ext-diff --quiet || echo '*')" ]; then
        dirty="*"
    fi

    if [ -n "$(git diff --no-ext-diff --cached --quiet || echo '+')" ]; then
        staged="+"
    fi

    if git rev-parse --verify --quiet refs/stash >/dev/null; then
        stash="$"
    fi

    if git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null; then
        untracked="%${ZSH_VERSION+%}"
    fi

    local status_info="$dirty$staged$stash$untracked"

    branch="${branch##refs/heads/}"
    printf -- " [%s]" "$branch${status_info:+$status_info}"
}



__git_ps1() {
    local git_info
    git_info="$(git rev-parse --is-inside-work-tree --short HEAD 2>/dev/null)"

    if [ -z "$git_info" ]; then
        return $?
    fi

    local branch
    if [ -h "$(git rev-parse --git-path HEAD 2>/dev/null)" ]; then
        branch="$(git symbolic-ref HEAD 2>/dev/null)"
    else
        local head_ref
        if ! __git_eread "$(git rev-parse --git-path HEAD)" head_ref; then
            return $?
        fi
        branch="${head_ref#ref: }"
    fi

    local dirty=""                      # should be in red
    local staged=""                     # should be in magenta
    local stash=""                      # should be in blue
    local untracked=""                  # should be in green
    local unpushed=""                   # should be in yellow

    if [ -n "$(git diff --no-ext-diff --quiet || echo '*')" ]; then
        dirty=" *dirty"
    fi

    if [ -n "$(git diff --no-ext-diff --cached --quiet || echo '+')" ]; then
        staged=" +staged"
    fi

    if git rev-parse --verify --quiet refs/stash >/dev/null; then
        stash=" \$stash"
    fi

    if git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null; then
        untracked=" %untracked"
    fi

    local count_unpushed=$(git rev-list --count --left-right @{upstream}...HEAD | awk '{print $2}')
    if (( "$count_unpushed" > 0 )); then
        unpushed=" â†‘$count_unpushed"
    fi

    local status_info="$dirty$staged$stash$untracked$unpushed"

    branch="${branch##refs/heads/}"
    printf -- " (%s)" "$branch$(tput setaf 6)${status_info:+$status_info}$(tput setaf 3)"
}

# Set the in-memory history size.  This controls the number of commands
# available for the current session.
export HISTSIZE=5000

# Set the on-disk history size.  This controls the number of commands stored in
# the history file.
export HISTFILESIZE=$HISTSIZE

# Set the history timestamp format to ISO8601 (yyyy-mm-dd hh:mm).
export HISTTIMEFORMAT="%Y-%m-%d %H:%M  "

# Exclude common navigation and administrative commands from history.
export HISTIGNORE="ls:cd:pwd:clear:history:exit:top:df"
