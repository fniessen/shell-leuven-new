#!/usr/bin/env bash

if [ -r ~/.dircolors ]; then
    eval "$(dircolors ~/.dircolors)"
fi

export PATH="$HOME/winbin:$HOME/bin:$PATH"

alias ll='ls -l'

alias g=git
alias hgrep='history | grep -i'

# Customize PS1 prompt.

# Define a custom function to display the exit code in red if it's non-zero.
show_exit_code() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        printf "\033[01;31m%s\033[00m\n" "$exit_code"
    else
        printf "%s" ""
    fi
}

# Set the PROMPT_COMMAND to call the custom function.
PROMPT_COMMAND='show_exit_code'



PS1='\n\
\[\e]0;\u@\h: \w\a\]\
${debian_chroot:+($debian_chroot)}\
\[\033[01;32m\]\u@\h\[\033[00m\]\
\[\033[01;30m\]:\[\033[00m\]\
\[\033[01;34m\]\w\[\033[00m\] \
\[\033[01;33m\]($(git branch 2>/dev/null | grep '^*' | colrm 1 2))\
\[\033[0m\]\n\$ '

PS1='\n\
\[\e]0;\u@\h: \w\a\]\
${debian_chroot:+($debian_chroot)}\
\[\033[01;32m\]\u@\h\[\033[00m\]\
\[\033[01;30m\]:\[\033[00m\]\
\[\033[01;34m\]\w\[\033[00m\]\
\[\033[01;33m\]$(__git_ps1)\
\[\033[0m\]\n\$ '




# XXX Make use of color_prompt variable?

# Check if history search bindings are already set.
if ! bind -q history-search-backward &>/dev/null; then
    # If not set, configure Up and Down arrow keys for history search.
    bind '"\e[A": history-search-backward'   # Up arrow: Search backward in command history.
    bind '"\e[B": history-search-forward'    # Down arrow: Search forward in command history.
fi

# Configure HISTCONTROL to ignore both leading space and consecutive duplicates.
export HISTCONTROL=ignoreboth
# === default in Ubuntu



# Enable case-insensitive directory completion.
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"




__git_ps1() {
    local git_info
    git_info="$(git rev-parse --is-inside-work-tree --short HEAD 2>/dev/null)"

    if [[ -z "$git_info" ]]; then
        return $?
    fi

    local branch
    if [[ -h "$(git rev-parse --git-path HEAD 2>/dev/null)" ]]; then
        branch="$(git symbolic-ref HEAD 2>/dev/null)"
    else
        local head_ref
        if ! __git_eread "$(git rev-parse --git-path HEAD)" head_ref; then
            return $?
        fi
        branch="${head_ref#ref: }"
    fi

    local dirty=""                      # should be in red
    local staged=""                     # should be in magenta
    local stash=""                      # should be in blue
    local untracked=""                  # should be in green
    local unpushed=""                   # should be in yellow

    if [[ -n "$(git diff --no-ext-diff --quiet || echo '*')" ]]; then
        dirty=" *dirty"
    fi

    if [[ -n "$(git diff --no-ext-diff --cached --quiet || echo '+')" ]]; then
        staged=" +staged"
    fi

    if git rev-parse --verify --quiet refs/stash >/dev/null; then
        stash=" \$stash"
    fi

    if git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null; then
        untracked=" ?untracked"
    fi

    local count_unpushed=0
    local upstream_branch="$(git rev-parse --abbrev-ref @{u} 2>/dev/null)"

    if [[ -n "$upstream_branch" ]]; then
        count_unpushed=$(git rev-list --count --left-right @{u}...HEAD | awk '{print $2}')
    fi

    if (( count_unpushed > 0 )); then
        unpushed=" â†‘$count_unpushed"
    fi

    local status_info="$dirty$staged$stash$untracked$unpushed"

    branch="${branch##refs/heads/}"
    printf -- " (%s)" "$branch$(tput setaf 6)${status_info:+$status_info}$(tput setaf 3)"
}

# Set the in-memory history size.  This controls the number of commands
# available for the current session.
export HISTSIZE=10000

# Set the on-disk history size.  This controls the number of commands stored in
# the history file.
export HISTFILESIZE=$HISTSIZE

# Set the history timestamp format to ISO8601 (yyyy-mm-dd hh:mm).
export HISTTIMEFORMAT="%Y-%m-%d %H:%M  "

# Exclude common navigation and administrative commands from history.
export HISTIGNORE="ls:cd:pwd:clear:history:exit:top:df"

# Detect the current shell.
case "$SHELL" in
    */bash)
        # Set a common history file.
        HISTFILE=$HOME/.bash_history

        # Append to the history file instead of overwriting.
        shopt -s histappend
        ;;
    */zsh)
        # Set a common history file.
        HISTFILE=$HOME/.zsh_history

        # Append to the history file instead of overwriting.
        setopt APPEND_HISTORY

        # Show full command history without line numbers.
        alias history="history 0"
        ;;
esac






alias lsd='ls -d */'
alias l='ls -CF'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

alias -- -='cd -'
alias back='cd -'

alias d='dirs -v'
alias 1='cd -1'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
alias 6='cd -6'
alias 7='cd -7'
alias 8='cd -8'
alias 9='cd -9'

# autopushd() {
#     if [[ -n "$BASH_VERSION" ]]; then
#         # For Bash.
#         old_dir="$(pwd)"
#         builtin cd "$@"
#         if [[ ":$DIRSTACK:" != *":$old_dir:"* ]]; then
#             echo "Bash - Pushing $old_dir onto the stack:"
#             pushd "$old_dir"
#         else
#             echo "Bash - Directory already in stack, not pushing."
#         fi
#     elif [[ -n "$ZSH_VERSION" ]]; then
#         # For Zsh.
#         old_dir="$(pwd)"
#         cd "$@"
#         if [[ ! -v dirstack || ":$DIRSTACK:" != *":$old_dir:"* ]]; then
#             echo "Zsh - Pushing $old_dir onto the stack:"
#             pushd "$old_dir"
#         else
#             echo "Zsh - Directory already in stack, not pushing."
#         fi
#     fi
# }
#
# alias cd='autopushd'


export GREP_COLORS='ms=01;31:mc=01;31:sl=:cx=:fn=35:ln=32'
