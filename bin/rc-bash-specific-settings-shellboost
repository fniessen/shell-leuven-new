#!/usr/bin/env bash

# Last modified: <20250801.1133>

# Set the maximum directory stack size to 10.
DIRSTACKSIZE=10
export DIRSTACKSIZE

# Check if realpath is available; if not, warn about potential issues.
if ! command -v realpath > /dev/null 2>&1; then
    printf >&2 "Warning: 'realpath' not found. Directory stack normalization may not work correctly.\n"
fi

# Custom cd function that maintains a directory stack with unique entries.
cd() {
    # Attempt to change directory using built-in cd.
    if builtin cd "$@" 2> /dev/null; then
        # Normalize the current directory path for comparison.
        local current_dir
        current_dir=$(realpath "$PWD" 2> /dev/null || printf "%s\n" "$PWD")

        # Get the current directory stack without the top entry (current dir).
        local stack
        stack=$(dirs -p -l | tail -n +2)

        # Clear the existing stack to rebuild it without duplicates.
        while popd -n > /dev/null 2>&1; do :; done

        # Rebuild the stack, excluding the current directory.
        local temp_stack=()
        while IFS= read -r dir; do
            # Normalize directory path for comparison.
            local normalized_dir
            normalized_dir=$(realpath "$dir" 2> /dev/null || printf "%s\n" "$dir")
            if [[ "$normalized_dir" != "$current_dir" ]]; then
                temp_stack+=("$dir")
            fi
        done <<< "$stack"

        # Push unique directories back to the stack, respecting DIRSTACKSIZE.
        local stack_size=${#temp_stack[@]}
        for ((i=$stack_size-1; i>=0 && stack_size<${DIRSTACKSIZE:-10}-1; i--)); do
            pushd -n "${temp_stack[$i]}" > /dev/null 2>&1
            ((stack_size++))
        done

        # Add the current directory to the stack.
        pushd -n "$PWD" > /dev/null 2>&1

        # # Provide feedback (show stack excluding the current directory at index 0).
        # dirs -v | tail -n +2 | head -n 9 | sed 's/^ //'
    else
        printf >&2 "cd: Failed to change directory to: %s\n" "$*"
        return 2
    fi
}

# Jump to a directory by visible stack index (as shown in 'dirs -v').
jumpd() {
    local index="$1"

    if ! [[ "$index" =~ ^[0-9]+$ ]]; then
        printf >&2 "jumpd: Index must be a non-negative number\n"
        return 64                       # EX_USAGE: Command-line usage error.
    fi

    local line
    line=$(dirs -v | awk -v idx="$index" '$1 == idx { $1=""; sub(/^ +/, ""); print }')

    if [ -z "$line" ]; then
        printf >&2 "jumpd: Invalid index: %s\n" "$index"
        return 65                       # EX_DATAERR: Data format error.
    fi

    # Expand ~ using eval.
    local target_dir
    target_dir=$(eval printf "%s\\\n" "$line") # With newline.

    if builtin cd "$target_dir" 2> /dev/null; then
        # Successfully changed directory, do nothing.
        :
    else
        printf >&2 "jumpd: Failed to cd to: %s\n" "$target_dir"
        return 71                       # EX_OSERR: System error.
    fi
}

# Define cdN() functions for switching to specific stack entries using jumpd.
for i in {1..9}; do
  eval "cd$i() { jumpd $i; }"
done
# 'cd1' moves to the most recent directory.
# 'cd2' moves to the second most recent directory.
# etc.

# M-S-l: Send the string 'ls' followed by a newline.
bind '"\eL": "ls\n"'

# C-M-u: Move to parent directory.
bind '"\e\C-u": "cd ..\n"'

# M-s: Prepend sudo.
bind '"\es": "\C-asudo \C-e"'

# Function to copy the previous word before the cursor.
copy-prev-word() {
    local line="$READLINE_LINE"
    local point=$READLINE_POINT

    # Get the part of the line before the cursor.
    local left="${line:0:point}"

    # Use regex to match the last word before the cursor (including trailing
    # spaces).
    if [[ "$left" =~ ([^[:space:]]+)[[:space:]]*$ ]]; then
        local word="${BASH_REMATCH[1]}"

        # Insert the word at the cursor position.
        READLINE_LINE="${line:0:point}$word${line:point}"

        # Move the cursor forward past the inserted word.
        READLINE_POINT=$((point + ${#word}))
    fi
}

# Bind the function to C-x C-d.
bind -x '"\C-x\C-d":copy-prev-word'

# Function to run help on the current command
run-help() {
    # Get the first word of the last command (i.e., the last command in the
    # pipeline or sequence).
    local cmd=$(printf "%s" "$READLINE_LINE" | awk -F'\\||;' '{print $NF}' | awk '{print $1}')

    # Check if there's a command to process.
    if [[ -n "$cmd" ]]; then
        # Show the man page for the command (if it exists).
        man "$cmd" 2> /dev/null || {
            # If no man page, use the `whatis` command for a brief description.
            whatis "$cmd" || printf "No help available for '%s'.\n" "$cmd"
        }
    else
        printf "No command to show help for.\n"
        return 1
    fi
}

# Bind the function run-help to M-h.
bind -x '"\eh": run-help'

# ───────────────────────────────────────────────────────────────
# Powerline-style Git-enhanced Bash prompt with simulated RPROMPT.
# ───────────────────────────────────────────────────────────────

# Check if 'git' command is available.
if ! command -v git > /dev/null 2>&1; then
    printf >&2 "\033[1;37;41mERROR: 'git' command not found.\033[0m\n"
fi

__git_ps1() {
    git rev-parse --is-inside-work-tree > /dev/null 2>&1 || return
    local branch status dirty staged stash untracked outgoing incoming

    branch="$(git symbolic-ref --short -q HEAD 2> /dev/null || git rev-parse --short HEAD 2> /dev/null)"

    # Custom colors.
    local GIT_DIRTY_COLOR="\033[31;1m"
    local GIT_STAGED_COLOR="\033[32;1m"     # Green (good to go / ready).
    local GIT_STASH_COLOR="\033[36m"        # Cyan (info).
    local GIT_UNTRACKED_COLOR="\033[33;1m"  # Yellow (warning light).
    local GIT_OUTGOING_COLOR="\033[35;1m"   # Purple for contrast.
    local GIT_INCOMING_COLOR="\033[36;1m"   # Cyan (info).

    # Color the markers, don't reset immediately.
    # Dirty (unstaged).
    if ! git diff --quiet --no-ext-diff; then
        dirty="${GIT_DIRTY_COLOR}●"
    fi

    # Staged.
    if ! git diff --cached --quiet; then
        staged="${GIT_STAGED_COLOR}+"
    fi

    # Stash.
    if git rev-parse --verify --quiet refs/stash > /dev/null 2>&1; then
        stash="${GIT_STASH_COLOR}\$"
    fi

    # Untracked.
    if git ls-files --others --exclude-standard 2> /dev/null | grep -q .; then
        untracked="${GIT_UNTRACKED_COLOR}?"
    fi

    # Ahead / Behind.
    if git rev-parse --abbrev-ref @{u} &> /dev/null 2>&1; then
        local counts count_outgoing count_incoming
        counts="$(git rev-list --left-right --count HEAD...@{u} 2> /dev/null)"
        count_outgoing=$(printf "%s\n" "$counts" | awk '{print $1}')
        count_incoming=$(printf "%s\n" "$counts" | awk '{print $2}')
        (( count_outgoing > 0 )) && outgoing="${GIT_OUTGOING_COLOR}▲$count_outgoing"
        (( count_incoming > 0 )) && incoming="${GIT_INCOMING_COLOR}▼$count_incoming"
    fi

    status="$dirty$staged$stash$untracked$outgoing$incoming"
    [[ -n "$status" ]] && status=" $status"

    printf "%b\n" "$branch$status"
}

# Display exit code at right if non-zero.
show_exit_code_rprompt() {
    local exit_code=$1
    if [[ $exit_code -ne 0 ]]; then
        local separator_left=""
        local white_square="■"

        # BSD-style symbolic names for exit codes 64-78.
        local -A bsd_exit_codes=(
            [64]="EX_USAGE"
            [65]="EX_DATAERR"
            [66]="EX_NOINPUT"
            [67]="EX_NOUSER"
            [68]="EX_NOHOST"
            [69]="EX_UNAVAILABLE"
            [70]="EX_SOFTWARE"
            [71]="EX_OSERR"
            [72]="EX_OSFILE"
            [73]="EX_CANTCREAT"
            [74]="EX_IOERR"
            [75]="EX_TEMPFAIL"
            [76]="EX_PROTOCOL"
            [77]="EX_NOPERM"
            [78]="EX_CONFIG"
        )

        local symbolic_name=""
        if [[ ${bsd_exit_codes[$exit_code]+_} ]]; then
            symbolic_name=" (${bsd_exit_codes[$exit_code]})"
        fi

        local msg=" Exit $exit_code$symbolic_name"

        # Colors.
        local sep_color="\033[31;40m"       # Red fg on black bg.
        local msg_color="\033[1;37;41m"     # White fg on red bg.
        local square_color="\033[1;37;41m"  # White on red.
        local reset_color="\033[0m"

        # Format parts (do NOT include trailing space inside color!).
        local formatted_sep="${sep_color}${separator_left}${reset_color}"
        local formatted_msg="${msg_color}${msg}"
        local formatted_square="${square_color}${white_square} ${reset_color}"

        # Calculate visible length.
        local visible_len=$((${#msg} + 4))  #  + msg + ■ + 1 space.

        local term_cols=$(tput cols)
        local padding=$(( term_cols - visible_len ))

        printf "\033[s"                             # Save cursor.
        printf "\033[1G\033[%dC" "$padding"         # Move to column.
        printf "%b%b %b" "$formatted_sep" "$formatted_msg" "$formatted_square"
        printf "\033[u"                             # Restore cursor.
    fi
}

set_prompt() {
    # Powerline separators.
    local SEPARATOR_RIGHT=""
    local SEPARATOR_LEFT=""

    # Colors (with proper Bash escapes).
    local RESET="\[\033[0m\]"

    local USER_BG="\[\033[48;5;136m\]"
    local USER_FG="\[\033[38;5;234m\]"

    local DIR_BG="\[\033[48;5;25m\]"
    local DIR_FG="\[\033[38;5;15m\]"

    local GIT_BG="\[\033[48;5;240m\]"
    local GIT_FG="\[\033[38;5;15m\]"

    local FINAL_BG="\[\033[48;5;0m\]"         # Final background (e.g. black).
    local GIT_SEP_FG="\[\033[38;5;240m\]"     # Foreground same as GIT_BG for seamless look.
    local FINAL_SEP_FG="\[\033[38;5;25m\]"    # Match DIR_BG for clean blue separator.
    # Prompt assembly.
    PS1=""

    # First line: user@host and working directory.
    PS1+="\n"
    PS1+="${USER_BG}${USER_FG}\u@\h ${RESET}${DIR_BG}\[\033[38;5;136m\]${SEPARATOR_RIGHT}${RESET}"
    PS1+="${DIR_BG}${DIR_FG} \w ${RESET}"

    # Git status, only if inside repo.
    if git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        PS1+="${GIT_BG}\[\033[38;5;25m\]${SEPARATOR_RIGHT}${RESET}"
        PS1+="${GIT_BG}${GIT_FG} \$(__git_ps1) ${RESET}"
        PS1+="${GIT_SEP_FG}${FINAL_BG}${SEPARATOR_RIGHT}${RESET}"
    else
        # Always add a final left separator in blue if not inside Git.
        PS1+="${FINAL_SEP_FG}${FINAL_BG}${SEPARATOR_RIGHT}${RESET}"
    fi

    # Second line: prompt symbol.
    PS1+="\n\[\033[1m\]\$ \[\033[0m\]"
}

# Preserve last exit code, show right prompt, then set PS1.
PROMPT_COMMAND='last=$?; show_exit_code_rprompt $last; set_prompt'

# Check if history search bindings are already set.
if ! bind -q history-search-backward > /dev/null 2>&1; then
    # If not set, configure Up and Down arrow keys for history search.
    bind '"\e[A": history-search-backward'  # Up arrow: Search backward in command history.
    bind '"\e[B": history-search-forward'   # Down arrow: Search forward in command history.
fi

# Enable case-insensitive directory completion.
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"

# Set a common history file.
HISTFILE=$HOME/.bash_history

# Set the number of history entries to save to the (on-disk history) file.
export HISTFILESIZE=20000

# Append to the history file instead of overwriting it.
shopt -s histappend

# Add history management to the existing PROMPT_COMMAND: after each command,
# append to the history file and reload it.
if [ -n "$PROMPT_COMMAND" ]; then
    PROMPT_COMMAND="$PROMPT_COMMAND; history -a; history -n"
else
    PROMPT_COMMAND="history -a; history -n"
fi
